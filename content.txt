FCC Learn Recursion - Building Decimal to Binary Converter

CONTENT:
1. element.addEventListener('onkeydown', callback_function);
  > event triggered when key is pressed
  > ex: 
  numberInput.addEventListener('keydown', () => {});

2. (KNOWLEDGE) whenever an event is triggered an event object is created automatically.
  > We can log the event and see what happen when a certain event is triggered.
  > ex:
  numberInput.addEventListener("keydown", (e) => {
    console.log(e);
  });

3. e.key
  >  tells you the string value of the key that was pressed.
  > ex:
  numberInput.addEventListener("keydown", (e) => {
    console.log(e.key);
  });

4. parseInt(string);
  > A good way to check and normalize numbers in JavaScript is to use the built-in parseInt() function, which converts a string into an integer or whole number. parseInt() takes at least one argument, a string to be converted into an integer, and returns either an integer or NaN which stands for Not a Number. 
  > ex:
  parseInt(2.2); // 2
  parseInt("2e+3"); // 2
  parseInt("e") // NaN

5. isNaN('')
  > This function takes in a string or number as an argument, and returns true if it evaluates to NaN.
  > ex:
  isNaN("test"); // true
  isNaN(2); // false
  isNaN("3.5"); // false

6. (KNOWLEDGE) About Binary
  > Binary numbers are a base-2 number system. Unlike the base-10 or decimal number system we use every day that uses 10 digits (0-9) to form numbers, the binary number system only has two digits, 0 and 1. In computer science, these binary digits are called bits, and are the smallest unit of data computers can process. For computers, 0 represents false or "off", and 1 represents true or "on".
  > In the base-2 number system, the rightmost digit represents the ones place, the next digit to the left represents the twos place, then the fours place, then the eights place, and so on. In this system, each digit's place value is two times greater than the digit to its right.
  > binary order in 8 bit or 1 byte:
  128 | 64 | 32 | 16 | 8 | 4 | 2 | 1
  > ex decimal to binary:
  1. 118 = "01110110";
  2. 3 = "00000011";

7. (CONCEPT) Recursion & (CONCEPT) Stack
  > A recursive function is a function that calls itself over and over. But you have to be careful because you can easily create an infinite loop. That's where the base case comes in. The base case is when the function stops calling itself, and it is a good idea to write it first.
  > When writing the recursive case, you need to remember two things:
    1. What is the base case?
    2. What is the least amount of work you need to do to get closer to the base case?

  > In computer science, a stack is a data structure where items are stored in a LIFO (last-in-first-out) manner. If you imagine a stack of books, the last book you add to the stack is the first book you can take off the stack. Or an array where you can only .push() and .pop() elements.
  > The call stack is a collection of function calls stored in a stack structure. When you call a function, it is added to the top of the stack, and when it returns, it is removed from the top / end of the stack.
  > callstack illustration:
  //learn recursion
  function a(){
    return "freeCodeCamp" + b();
  }

  function b() {
    return "is " + c();
  }

  function c() {
    return "awesome!";
  }

  console.log(a()); //freeCodeCamp is awesome!

  const callStack = [
    'a(): returns "freeCodeCamp " + b()',
    'b(): returns "is " + c()',
    'c(): returns "awesome!"'
  ];
  > When a() is called, it creates a callstack, with a as the first item, b as the second, and lastly c, and coz stack is using LIFO concept, c is excuted first, and after it finishes c removed from the stack, and b is then to be executed, continue again until the stack is empty.

8. String function in JavaScript  
  > For a reliable way to convert a value into a string, even falsy values like null and undefined, you can use the String() function.
  > ex:
  const num = 5;
  console.log(String(num)); // "5"
  console.log(String(null)); // "null"

9. setTimeout(() => {}, time)
  > The setTimeout function takes two arguments: a callback function and a number representing the time in milliseconds to wait before executing the callback function.
  > ex:
  setTimeout(() => {
    console.log("Hello, world!");
  }, 3000);
  > the log above will appear after 3000ms == 3seconds
  > NOTE: setTimeout() function is asynchronous, meaning that it doesn't stop the execution of the rest of your code.
  > ex:
  console.log('free');
  setTimeout(() => {
    console.log("Code");
  }, 1000);
  console.log('Camp');
  > the result of the above code is: freeCampCode instead of freeCodeCamp, the explanation is above.
  > While asynchronous, or async, code can be difficult to understand at first, it has many advantages. One of the most important is that it allows you to write non-blocking code.
  > For example, imagine you're baking a cake, and you put the cake in the oven and set a timer. You don't have to sit in front of the oven waiting the entire time â€“ you can wash dishes, read a book, or do anything else while you wait for the timer to go off.> Async code works in a similar way. You can start an async operation and other parts of your code will still work while that operation is running.

10. 

